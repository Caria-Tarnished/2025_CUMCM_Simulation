# -*- coding: utf-8 -*-
"""生产过程决策的动态规划模型

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1_2rMwLuqUkJA69abzoI-N_ReBueY2nx5
"""

import pandas as pd

# --- 1. 定义问题2中给出的六种情景的数据 ---
# 数据源: CUMCM-2024-problem B-Chinese.pdf, 表1
scenarios = {
    "情景1": {
        'p_c1': 0.10, 'cost_buy_c1': 4, 'cost_inspect_c1': 2,
        'p_c2': 0.10, 'cost_buy_c2': 18, 'cost_inspect_c2': 3,
        'p_a': 0.10, 'cost_assembly': 6, 'cost_inspect_prod': 3,
        'sale_price': 56, 'replace_loss': 6, 'cost_dismantle': 5
    },
    "情景2": {
        'p_c1': 0.20, 'cost_buy_c1': 4, 'cost_inspect_c1': 2,
        'p_c2': 0.20, 'cost_buy_c2': 18, 'cost_inspect_c2': 3,
        'p_a': 0.20, 'cost_assembly': 6, 'cost_inspect_prod': 3,
        'sale_price': 56, 'replace_loss': 6, 'cost_dismantle': 5
    },
    "情景3": {
        'p_c1': 0.10, 'cost_buy_c1': 4, 'cost_inspect_c1': 2,
        'p_c2': 0.10, 'cost_buy_c2': 18, 'cost_inspect_c2': 3,
        'p_a': 0.10, 'cost_assembly': 6, 'cost_inspect_prod': 3,
        'sale_price': 56, 'replace_loss': 30, 'cost_dismantle': 5
    },
    "情景4": {
        'p_c1': 0.20, 'cost_buy_c1': 4, 'cost_inspect_c1': 1,
        'p_c2': 0.20, 'cost_buy_c2': 18, 'cost_inspect_c2': 1,
        'p_a': 0.20, 'cost_assembly': 6, 'cost_inspect_prod': 2,
        'sale_price': 36, 'replace_loss': 30, 'cost_dismantle': 5
    },
    "情景5": {
        'p_c1': 0.10, 'cost_buy_c1': 4, 'cost_inspect_c1': 8,
        'p_c2': 0.20, 'cost_buy_c2': 18, 'cost_inspect_c2': 1,
        'p_a': 0.10, 'cost_assembly': 6, 'cost_inspect_prod': 2,
        'sale_price': 56, 'replace_loss': 10, 'cost_dismantle': 5
    },
    "情景6": {
        'p_c1': 0.05, 'cost_buy_c1': 4, 'cost_inspect_c1': 2,
        'p_c2': 0.05, 'cost_buy_c2': 18, 'cost_inspect_c2': 3,
        'p_a': 0.05, 'cost_assembly': 6, 'cost_inspect_prod': 3,
        'sale_price': 56, 'replace_loss': 10, 'cost_dismantle': 40
    }
}


def solve_scenario(params):
    """
    为单个情景计算最优决策方案。
    该函数会遍历所有16种可能的决策组合，并找出利润最高的一种。
    """
    best_strategy = None
    max_profit = -float('inf')

    # 遍历所有可能的决策组合 (True=是, False=否)
    for inspect_c1 in [True, False]:
        for inspect_c2 in [True, False]:
            for inspect_prod in [True, False]:
                for dismantle in [True, False]:

                    # --- 1. 计算进入装配环节的零配件的有效成本和有效次品率 ---
                    # 如果检测，次品被剔除，有效次品率为0，但成本是获取一个合格品的期望成本
                    if inspect_c1:
                        # 避免除以零的错误 (如果次品率为100%)
                        if params['p_c1'] >= 1.0: continue
                        cost_eff_c1 = (params['cost_buy_c1'] + params['cost_inspect_c1']) / (1 - params['p_c1'])
                        p_eff_c1 = 0
                    else:
                        cost_eff_c1 = params['cost_buy_c1']
                        p_eff_c1 = params['p_c1']

                    if inspect_c2:
                        if params['p_c2'] >= 1.0: continue
                        cost_eff_c2 = (params['cost_buy_c2'] + params['cost_inspect_c2']) / (1 - params['p_c2'])
                        p_eff_c2 = 0
                    else:
                        cost_eff_c2 = params['cost_buy_c2']
                        p_eff_c2 = params['p_c2']

                    # --- 2. 计算成品的总次品率 ---
                    # 产品合格的概率 = P(C1合格) * P(C2合格) * P(装配合格)
                    p_prod_ok = (1 - p_eff_c1) * (1 - p_eff_c2) * (1 - params['p_a'])
                    p_prod_defect = 1 - p_prod_ok

                    # --- 3. 计算单位产品的总期望成本 C_total ---
                    # C_total 是生产一个最终交付给用户的合格品的总成本

                    # C_asm 是组装一个成品的期望成本
                    C_asm = cost_eff_c1 + cost_eff_c2 + params['cost_assembly']

                    if not inspect_prod:
                        # 策略：不检测成品
                        # 此时，次品会流向市场，产生调换损失和重置成本
                        # C_total = C_asm + p_prod_defect * (L_replace + C_total)
                        # 解得: C_total = (C_asm + p_prod_defect * L_replace) / (1 - p_prod_defect)
                        if p_prod_defect >= 1.0: continue # 无法交付合格品，成本无限大
                        C_total = (C_asm + p_prod_defect * params['replace_loss']) / (1 - p_prod_defect)
                    else:
                        # 策略：检测成品
                        # 此时，次品在出厂前被拦截，不会有市场失灵
                        C_attempt = C_asm + params['cost_inspect_prod']

                        if not dismantle:
                            # 子策略：报废不合格品
                            # 需要不断尝试，直到生产出一个合格品为止 (几何分布)
                            # C_total = C_attempt / P(合格)
                            if p_prod_ok == 0: continue
                            C_total = C_attempt / p_prod_ok
                        else:
                            # 子策略：拆解不合格品
                            # 失败后，付出拆解成本，但回收了零配件，只需重新投入装配和检测成本
                            if p_prod_ok == 0: continue
                            cost_rework = params['cost_assembly'] + params['cost_dismantle'] + params['cost_inspect_prod']
                            # C_total = C_attempt + (P(不合格)/P(合格)) * cost_rework
                            C_total = C_attempt + (p_prod_defect / p_prod_ok) * cost_rework

                    # --- 4. 计算利润并更新最优策略 ---
                    profit = params['sale_price'] - C_total

                    if profit > max_profit:
                        max_profit = profit
                        best_strategy = {
                            "决策：检测零配件1": "是" if inspect_c1 else "否",
                            "决策：检测零配件2": "是" if inspect_c2 else "否",
                            "决策：检测成品": "是" if inspect_prod else "否",
                            "决策：拆解不合格品": "是" if dismantle else "否",
                            "单位产品期望净利润 (元)": round(max_profit, 2)
                        }

    return best_strategy

# --- 主程序 ---
# 存储所有情景的结果
results = []

# 遍历并求解每个情景
for name, params in scenarios.items():
    optimal_strategy = solve_scenario(params)
    # 在结果中加入情景名称
    strategy_with_name = {"情景": name, **optimal_strategy}
    results.append(strategy_with_name)

# 使用 pandas DataFrame 格式化输出结果，使其清晰美观
df_results = pd.DataFrame(results)

# 调整列的顺序以匹配 .md 文件中的表格
column_order = [
    "情景",
    "决策：检测零配件1",
    "决策：检测零配件2",
    "决策：检测成品",
    "决策：拆解不合格品",
    "单位产品期望净利润 (元)"
]
df_results = df_results[column_order]

# 打印最终的决策方案表格
print("--- 问题2：六种情景下的最优决策方案与经济指标 ---")
print(df_results.to_string(index=False))

# --- 决策依据分析 ---
print("\n--- 决策依据分析摘要 ---")
# 情景2 vs 情景1
profit_s1 = df_results.loc[df_results['情景'] == '情景1', '单位产品期望净利润 (元)'].iloc[0]
profit_s2 = df_results.loc[df_results['情景'] == '情景2', '单位产品期望净利润 (元)'].iloc[0]
print(f"1. 次品率影响 (情景1 vs 2): 当次品率从10%升至20%，利润从 {profit_s1} 元骤降至 {profit_s2} 元。模型决策从【不检测零配件】转向【全面检测】，说明高次品率迫使企业投入前期成本以避免后期更大的损失。")

# 情景3 vs 情景1
profit_s3 = df_results.loc[df_results['情景'] == '情景3', '单位产品期望净利润 (元)'].iloc[0]
print(f"2. 调换损失影响 (情景1 vs 3): 当调换损失从6元增至30元，利润从 {profit_s1} 元降至 {profit_s3} 元。两种情景的最优决策均为【检测成品】，这凸显了成品检测在规避高昂市场失灵成本中的关键作用。")

# 情景5
c_buy_c1_s5 = scenarios['情景5']['cost_buy_c1']
c_insp_c1_s5 = scenarios['情景5']['cost_inspect_c1']
print(f"3. 检测成本影响 (情景5): 零配件1的检测成本({c_insp_c1_s5}元)高于其购买单价({c_buy_c1_s5}元)，模型决策为【不检测零配件1】，符合经济直觉。")

# 情景6
c_buy_total_s6 = scenarios['情景6']['cost_buy_c1'] + scenarios['情景6']['cost_buy_c2']
c_dism_s6 = scenarios['情景6']['cost_dismantle']
print(f"4. 拆解费用影响 (情景6): 拆解费用({c_dism_s6}元)远高于重新购买一套零配件的成本({c_buy_total_s6}元)，模型决策为【不拆解】(即直接报废)，完全符合成本效益原则。")