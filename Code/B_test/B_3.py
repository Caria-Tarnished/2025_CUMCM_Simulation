# -*- coding: utf-8 -*-
"""复杂装配系统的动态规划决策模型

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1pmMNuREhWvGuIggJYFDfvf1T13AvuSx4
"""

import pandas as pd

# --- 1. 定义问题3的生产系统数据结构 ---
# 数据源: CUMCM-2024-problem B-Chinese.pdf, 图1和表2
# 我们使用一个字典来表示整个生产图 (DAG)
# 'components' 键指向其组成的子部件列表

production_system = {
    # 基础零配件 (叶节点)
    '零配件1': {'type': '零配件', 'p_defect': 0.10, 'cost_buy': 2, 'cost_inspect': 1, 'components': []},
    '零配件2': {'type': '零配件', 'p_defect': 0.10, 'cost_buy': 8, 'cost_inspect': 1, 'components': []},
    '零配件3': {'type': '零配件', 'p_defect': 0.10, 'cost_buy': 12, 'cost_inspect': 2, 'components': []},
    '零配件4': {'type': '零配件', 'p_defect': 0.10, 'cost_buy': 2, 'cost_inspect': 1, 'components': []},
    '零配件5': {'type': '零配件', 'p_defect': 0.10, 'cost_buy': 8, 'cost_inspect': 1, 'components': []},
    '零配件6': {'type': '零配件', 'p_defect': 0.10, 'cost_buy': 12, 'cost_inspect': 2, 'components': []},
    '零配件7': {'type': '零配件', 'p_defect': 0.10, 'cost_buy': 8, 'cost_inspect': 1, 'components': []},
    '零配件8': {'type': '零配件', 'p_defect': 0.10, 'cost_buy': 12, 'cost_inspect': 2, 'components': []},

    # 半成品 (中间节点)
    '半成品1': {'type': '半成品', 'p_defect': 0.10, 'cost_assembly': 8, 'cost_inspect': 6, 'cost_dismantle': 4, 'components': ['零配件1', '零配件2', '零配件3']},
    '半成品2': {'type': '半成品', 'p_defect': 0.10, 'cost_assembly': 8, 'cost_inspect': 4, 'cost_dismantle': 6, 'components': ['零配件4', '零配件5', '零配件6']},
    '半成品3': {'type': '半成品', 'p_defect': 0.10, 'cost_assembly': 8, 'cost_inspect': 4, 'cost_dismantle': 6, 'components': ['零配件7', '零配件8']},

    # 最终成品 (根节点)
    '成品': {'type': '成品', 'p_defect': 0.10, 'cost_assembly': 8, 'cost_inspect': 10, 'cost_dismantle': 6, 'sale_price': 200, 'replace_loss': 40, 'components': ['半成品1', '半成品2', '半成品3']}
}

# 使用备忘录 (Memoization) 来存储已计算过的节点结果，避免重复计算
memo = {}

def get_optimal_policy(item_name):
    """
    递归函数，用于计算任何给定部件的最优决策和最小期望成本。
    """
    # 如果结果已在备忘录中，直接返回
    if item_name in memo:
        return memo[item_name]

    item = production_system[item_name]

    # --- Base Case: 基础零配件 ---
    if item['type'] == '零配件':
        # 决策：是否检测该零配件？

        # 策略1: 不检测
        cost_no_inspect = item['cost_buy']
        p_eff_no_inspect = item['p_defect']

        # 策略2: 检测
        # 获得一个合格品的期望成本 = (购买成本 + 检测成本) / 合格率
        p_ok = 1 - item['p_defect']
        if p_ok == 0:
            cost_inspect = float('inf')
        else:
            cost_inspect = (item['cost_buy'] + item['cost_inspect']) / p_ok
        p_eff_inspect = 0 # 检测后送去装配的都是合格品

        # 比较成本，选择最优策略
        if cost_no_inspect < cost_inspect:
            result = {
                'optimal_cost': cost_no_inspect,
                'effective_p_defect': p_eff_no_inspect,
                'decision_inspect': '否'
            }
        else:
            result = {
                'optimal_cost': cost_inspect,
                'effective_p_defect': p_eff_inspect,
                'decision_inspect': '是'
            }
        memo[item_name] = result
        return result

    # --- Recursive Step: 半成品或成品 ---

    # 1. 首先，递归求解所有子部件的最优策略和成本
    sub_components_results = [get_optimal_policy(sub_name) for sub_name in item['components']]

    # 2. 计算组装一次的期望成本和合格率
    cost_of_sub_components = sum(res['optimal_cost'] for res in sub_components_results)
    cost_one_assembly_attempt = cost_of_sub_components + item['cost_assembly']

    # 合格率 = P(装配合格) * Π P(所有子部件都合格)
    p_ok_from_subs = 1.0
    for res in sub_components_results:
        p_ok_from_subs *= (1 - res['effective_p_defect'])

    p_ok_total = (1 - item['p_defect']) * p_ok_from_subs
    p_defect_total = 1 - p_ok_total

    # 3. 决策：对于检测出的次品，是拆解还是报废？
    # (此决策仅在“检测”策略下有意义)
    cost_rework_if_scrap = cost_one_assembly_attempt + item['cost_inspect']
    cost_rework_if_dismantle = item['cost_dismantle'] + item['cost_assembly'] + item['cost_inspect']

    if cost_rework_if_dismantle < cost_rework_if_scrap:
        optimal_rework_cost = cost_rework_if_dismantle
        decision_dismantle = '是'
    else:
        optimal_rework_cost = cost_rework_if_scrap
        decision_dismantle = '否'

    # 4. 决策：是否检测该成品/半成品？

    # 策略1: 检测
    if p_ok_total == 0:
        cost_inspect = float('inf')
    else:
        # 成本 = 首次尝试成本 + 后续返工的期望成本
        cost_inspect = (cost_one_assembly_attempt + item['cost_inspect']) + \
                       (p_defect_total / p_ok_total) * optimal_rework_cost

    # 策略2: 不检测 (只对最终成品有意义)
    if item['type'] == '成品':
        if p_defect_total >= 1.0:
            cost_no_inspect = float('inf')
        else:
            # C_total = (C_asm + p_defect * L_replace) / (1 - p_defect)
            cost_no_inspect = (cost_one_assembly_attempt + p_defect_total * item['replace_loss']) / (1 - p_defect_total)

        # 比较成本，选择最优策略
        if cost_no_inspect < cost_inspect:
            result = {
                'optimal_cost': cost_no_inspect,
                'effective_p_defect': p_defect_total,
                'decision_inspect': '否',
                'decision_dismantle': '不适用' # 因为不检测，所以无所谓拆解
            }
        else:
            result = {
                'optimal_cost': cost_inspect,
                'effective_p_defect': 0, # 检测后送向市场的都是合格品
                'decision_inspect': '是',
                'decision_dismantle': decision_dismantle
            }
    else: # 对于半成品，必须做出“检测”或“不检测”的决策，但没有“直接上市”的选项
          # 这里我们假设半成品必须检测，或者说不检测的风险太大，模型简化为必须检测
          # 一个更复杂的模型可以把不检测的风险（即增加下一阶段的次品率）也量化，但目前按题目简化处理
          # 根据题目隐含意图，半成品阶段的决策是是否增加一道质检工序
        cost_no_inspect = cost_one_assembly_attempt # 不检测的成本就是单次组装成本

        if cost_no_inspect < cost_inspect:
             result = {
                'optimal_cost': cost_no_inspect,
                'effective_p_defect': p_defect_total,
                'decision_inspect': '否',
                'decision_dismantle': '不适用'
            }
        else:
            result = {
                'optimal_cost': cost_inspect,
                'effective_p_defect': 0,
                'decision_inspect': '是',
                'decision_dismantle': decision_dismantle
            }


    memo[item_name] = result
    return result

# --- 主程序 ---
# 从最终成品开始，启动递归求解
final_product_result = get_optimal_policy('成品')

# 整理并输出结果
all_items = list(production_system.keys())
results_list = []

for item_name in all_items:
    # 确保所有节点都已计算
    if item_name not in memo:
        get_optimal_policy(item_name)

    res = memo[item_name]

    # 对拆解决策进行格式化
    dismantle_decision = res.get('decision_dismantle', '不适用')

    results_list.append({
        "项目": item_name,
        "类型": production_system[item_name]['type'],
        "最优决策：检测": res['decision_inspect'],
        "最优决策：拆解": dismantle_decision
    })

df_results = pd.DataFrame(results_list)

print("--- 问题3：复杂装配系统最优决策方案 ---")
print(df_results.to_string(index=False))

# 计算最终利润
final_cost = final_product_result['optimal_cost']
sale_price = production_system['成品']['sale_price']
final_profit = sale_price - final_cost

print("\n--- 最终经济指标 ---")
print(f"生产一件合格成品的最小期望成本: {final_cost:.2f} 元")
print(f"市场售价: {sale_price:.2f} 元")
print(f"单位产品期望净利润: {final_profit:.2f} 元")