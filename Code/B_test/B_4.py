# -*- coding: utf-8 -*-
"""考虑不确定性的随机动态规划模型

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1UJIcOeBsr6IVqX-lZgU3msG3ku3hux6o
"""

import pandas as pd
import copy

# --- 0. 导入并复用问题2和问题3的求解器代码 ---
# 为了代码的独立和完整性，我们将之前的求解器函数复制到这里。

# 问题2的求解器
def solve_scenario_q2(params):
    best_strategy = None
    max_profit = -float('inf')
    for inspect_c1 in [True, False]:
        for inspect_c2 in [True, False]:
            for inspect_prod in [True, False]:
                for dismantle in [True, False]:
                    if params['p_c1'] >= 1.0 or params['p_c2'] >= 1.0: continue
                    cost_eff_c1 = (params['cost_buy_c1'] + params['cost_inspect_c1']) / (1 - params['p_c1']) if inspect_c1 else params['cost_buy_c1']
                    p_eff_c1 = 0 if inspect_c1 else params['p_c1']
                    cost_eff_c2 = (params['cost_buy_c2'] + params['cost_inspect_c2']) / (1 - params['p_c2']) if inspect_c2 else params['cost_buy_c2']
                    p_eff_c2 = 0 if inspect_c2 else params['p_c2']
                    p_prod_ok = (1 - p_eff_c1) * (1 - p_eff_c2) * (1 - params['p_a'])
                    p_prod_defect = 1 - p_prod_ok
                    C_asm = cost_eff_c1 + cost_eff_c2 + params['cost_assembly']
                    if not inspect_prod:
                        if p_prod_defect >= 1.0: continue
                        C_total = (C_asm + p_prod_defect * params['replace_loss']) / (1 - p_prod_defect)
                    else:
                        C_attempt = C_asm + params['cost_inspect_prod']
                        if p_prod_ok == 0: continue
                        if not dismantle:
                            C_total = C_attempt / p_prod_ok
                        else:
                            cost_rework = params['cost_assembly'] + params['cost_dismantle'] + params['cost_inspect_prod']
                            C_total = C_attempt + (p_prod_defect / p_prod_ok) * cost_rework
                    profit = params['sale_price'] - C_total
                    if profit > max_profit:
                        max_profit = profit
                        best_strategy = {
                            "决策：检测零配件1": "是" if inspect_c1 else "否",
                            "决策：检测零配件2": "是" if inspect_c2 else "否",
                            "决策：检测成品": "是" if inspect_prod else "否",
                            "决策：拆解不合格品": "是" if dismantle else "否",
                            "单位产品期望净利润 (元)": round(max_profit, 2)
                        }
    return best_strategy

# 问题3的求解器 (带备忘录的递归DP)
def solve_scenario_q3(production_system):
    memo = {}
    def get_optimal_policy(item_name):
        if item_name in memo: return memo[item_name]
        item = production_system[item_name]
        if item['type'] == '零配件':
            p_ok = 1 - item['p_defect']
            cost_inspect = float('inf') if p_ok == 0 else (item['cost_buy'] + item['cost_inspect']) / p_ok
            cost_no_inspect = item['cost_buy']
            result = {'optimal_cost': cost_inspect, 'effective_p_defect': 0, 'decision_inspect': '是'} if cost_inspect < cost_no_inspect else {'optimal_cost': cost_no_inspect, 'effective_p_defect': item['p_defect'], 'decision_inspect': '否'}
        else: # 半成品或成品
            sub_results = [get_optimal_policy(sub) for sub in item['components']]
            cost_subs = sum(res['optimal_cost'] for res in sub_results)
            cost_attempt = cost_subs + item['cost_assembly']
            p_ok_subs = 1.0
            for res in sub_results: p_ok_subs *= (1 - res['effective_p_defect'])
            p_ok_total = (1 - item['p_defect']) * p_ok_subs
            p_defect_total = 1 - p_ok_total
            cost_rework_scrap = cost_attempt + item['cost_inspect']
            cost_rework_dismantle = item['cost_dismantle'] + item['cost_assembly'] + item['cost_inspect']
            optimal_rework_cost, decision_dismantle = (cost_rework_dismantle, '是') if cost_rework_dismantle < cost_rework_scrap else (cost_rework_scrap, '否')
            cost_inspect = float('inf') if p_ok_total == 0 else (cost_attempt + item['cost_inspect']) + (p_defect_total / p_ok_total) * optimal_rework_cost
            if item['type'] == '成品':
                cost_no_inspect = float('inf') if p_defect_total >= 1.0 else (cost_attempt + p_defect_total * item['replace_loss']) / (1 - p_defect_total)
                if cost_no_inspect < cost_inspect:
                    result = {'optimal_cost': cost_no_inspect, 'effective_p_defect': p_defect_total, 'decision_inspect': '否', 'decision_dismantle': '不适用'}
                else:
                    result = {'optimal_cost': cost_inspect, 'effective_p_defect': 0, 'decision_inspect': '是', 'decision_dismantle': decision_dismantle}
            else: # 半成品
                cost_no_inspect = cost_attempt
                if cost_no_inspect < cost_inspect:
                    result = {'optimal_cost': cost_no_inspect, 'effective_p_defect': p_defect_total, 'decision_inspect': '否', 'decision_dismantle': '不适用'}
                else:
                    result = {'optimal_cost': cost_inspect, 'effective_p_defect': 0, 'decision_inspect': '是', 'decision_dismantle': decision_dismantle}
        memo[item_name] = result
        return result
    final_result = get_optimal_policy('成品')
    return memo, final_result

# --- 1. 定义贝叶斯更新函数 ---
def get_posterior_mean(p_hat, n=100, alpha_prior=1, beta_prior=1):
    """
    根据次品率的点估计值，计算其后验均值。
    :param p_hat: 次品率的点估计值 (e.g., 0.10)
    :param n: 假设的样本量
    :param alpha_prior: 贝塔先验分布的alpha参数 (默认1, 代表均匀分布)
    :param beta_prior: 贝塔先验分布的beta参数 (默认1, 代表均匀分布)
    :return: 后验均值 E[p]
    """
    if p_hat < 0 or p_hat > 1:
        raise ValueError("次品率必须在 [0, 1] 之间")

    k = round(p_hat * n)  # 估计的次品数

    alpha_posterior = k + alpha_prior
    beta_posterior = (n - k) + beta_prior

    return alpha_posterior / (alpha_posterior + beta_posterior)

# --- 2. 重新求解问题2 ---
print("--- 问题4：重新评估问题2（考虑不确定性）---\n")

# 导入原始数据
from immersive_assets.dp_production_optimization_py import scenarios as scenarios_q2_deterministic

# 创建新数据副本以进行修改
scenarios_q2_stochastic = copy.deepcopy(scenarios_q2_deterministic)

# 更新所有次品率参数为后验均值
ASSUMED_N = 100
print(f"假设所有次品率估计均来自 n={ASSUMED_N} 的样本...")
for name, params in scenarios_q2_stochastic.items():
    params['p_c1'] = get_posterior_mean(params['p_c1'], n=ASSUMED_N)
    params['p_c2'] = get_posterior_mean(params['p_c2'], n=ASSUMED_N)
    params['p_a'] = get_posterior_mean(params['p_a'], n=ASSUMED_N)

# 求解确定性模型和随机模型
results_deterministic_q2 = []
results_stochastic_q2 = []
for name in scenarios_q2_deterministic.keys():
    det_res = solve_scenario_q2(scenarios_q2_deterministic[name])
    sto_res = solve_scenario_q2(scenarios_q2_stochastic[name])
    results_deterministic_q2.append({"模型": "确定性", "情景": name, **det_res})
    results_stochastic_q2.append({"模型": "随机性", "情景": name, **sto_res})

# 合并结果并进行对比
df_q2_det = pd.DataFrame(results_deterministic_q2)
df_q2_sto = pd.DataFrame(results_stochastic_q2)
df_q2_comparison = pd.concat([df_q2_det, df_q2_sto]).sort_values(by=['情景', '模型'], ascending=[True, False])
df_q2_comparison = df_q2_comparison.set_index(['情景', '模型'])

print("确定性模型 vs. 随机性模型 最优决策对比:")
print(df_q2_comparison.to_string())
print("\n分析: 在情景4中，由于随机模型下的期望次品率略微升高 (20% -> ~20.59%)，")
print("导致不检测成品的风险成本超过了其检测成本，因此最优决策从【否】变为【是】。")
print("这说明在决策临界点，对不确定性的建模至关重要。\n")


# --- 3. 重新求解问题3 ---
print("\n--- 问题4：重新评估问题3（考虑不确定性）---\n")

# 导入原始数据
from immersive_assets.dp_complex_assembly_py import production_system as system_q3_deterministic

# 创建新数据副本
system_q3_stochastic = copy.deepcopy(system_q3_deterministic)

# 更新所有次品率
for name, item in system_q3_stochastic.items():
    if 'p_defect' in item:
        item['p_defect'] = get_posterior_mean(item['p_defect'], n=ASSUMED_N)

# 求解随机模型
memo_sto, final_result_sto = solve_scenario_q3(system_q3_stochastic)

# 整理并输出结果
results_list_sto_q3 = []
for item_name, res in memo_sto.items():
    results_list_sto_q3.append({
        "项目": item_name,
        "类型": system_q3_stochastic[item_name]['type'],
        "最优决策：检测": res['decision_inspect'],
        "最优决策：拆解": res.get('decision_dismantle', '不适用')
    })

df_results_sto_q3 = pd.DataFrame(results_list_sto_q3)
df_results_sto_q3 = df_results_sto_q3.sort_values(by=['类型', '项目'])


print("考虑不确定性后的最优决策方案:")
print(df_results_sto_q3.to_string(index=False))

# 计算最终利润
final_cost_sto = final_result_sto['optimal_cost']
sale_price_sto = system_q3_stochastic['成品']['sale_price']
final_profit_sto = sale_price_sto - final_cost_sto

print("\n最终经济指标 (随机模型):")
print(f"生产一件合格成品的最小期望成本: {final_cost_sto:.2f} 元")
print(f"单位产品期望净利润: {final_profit_sto:.2f} 元")
print("\n分析: 在问题3的参数设置下，由于各阶段检测的成本效益非常显著，")
print("即使次品率的期望值有微小波动，也未改变【全面检测，全部拆解】的整体最优策略。")